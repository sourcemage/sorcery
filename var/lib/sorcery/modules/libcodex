#!/bin/bash
#---------------------------------------------------------------------
##
## @Synopsis Set of functions for dealing with a library of grimoires (spell books).
##
## A grimoire is a book containing one or more spells.  A codex
## is a collection of one or more grimoires.  There are functions
## for listing the available grimiores, listing spells in a grimoire,
## listing sections in a grimoire, etc.
##
## Note:  Each of the functions that returns a spell, section, or 
## grimoire returns the full path.  Functions that explicitly return 
## a spell I<name> or section I<name> do not return the full
## path.
##
## <br>grimoires<br>
##
## This section contains some notes on grimoires.
##
## <br>Grimoire Layout<br>
## The codex functions expect each grimoire to be a directory.
## Each directory entry in a grimoire directory is considered 
## to be a section.  All directory entries in a section are 
## considered to be a spell if they included an executable file
## named F<DETAILS>.
##
## <br>Multiple grimoires<br>
## 
## Multiple grimoires are specified by setting entries in the
## I<GRIMOIRE_DIR> array.  For example, to set two additional 
## grimoires, you would put something like the following in 
## your local SMGL grimoire file (F</etc/sorcery/local/grimoire>).
## <pre>
##     GRIMOIRE_DIR[1]=/path/to/alternate/grimoire
##     GRIMOIRE_DIR[2]=/path/to/other/alternate/grimoire
## </pre>
## Grimoires are processed/searched in increasing order starting 
## at index 0.  The SMGL configuration file provides the value for
## the default grimoire as I<GRIMOIRE_DIR[0]> or simply I<GRIMOIRE_DIR>.
##
## The following two lines show how to reorder the default 
## grimoire so that it's not searched first (in this example
## it will be searched second).
## <pre>
##     GRIMOIRE_DIR[1]=$GRIMOIRE
##     GRIMOIRE_DIR[0]=/path/to/grimoire/to/search/first
## </pre>
## There is no limitation on the number of grimoires that can be
## specified.
##
## It is also possible to add and remove grimoires using the 
## codex_add_grimoire and codex_remove_grimoire functions.
##
## @Copyright
##
## Copyright 2002 by the Source Mage Team
##
##
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## Removes duplicate entries from the GRIMOIRE_LIST. This parses from
## 0 on up, and leaves only the first instance of a grimoire found.
## All others are removed.
## Then reloads the list
##
#---------------------------------------------------------------------
function codex_remove_duplicates() {

  local  GRIMOIRES=`codex_get_all_grimoires`
  local  CURRENT_GRIMOIRE=0
  local  GRIMOIRE_COUNT=0
  local  SEEN_GRIMOIRES=""
  local  ALREADY_SEEN=""

 
  touch  $GRIMOIRE_LIST
  tGRIMOIRE_LIST=`lock_start_transaction $GRIMOIRE_LIST`
#  cp     $GRIMOIRE_LIST  $GRIMOIRE_LIST_BACKUP
  rm  -f $tGRIMOIRE_LIST   


  for  CURRENT_GRIMOIRE  in  $GRIMOIRES;  do
    ALREADY_SEEN=""
    echo "$SEEN_GRIMOIRES" | grep "$CURRENT_GRIMOIRE" && ALREADY_SEEN="yes"

    if [[  $ALREADY_SEEN  ]]; then
      SEEN_GRIMOIRES="$SEEN_GRIMOIRES $CURRENT_GRIMOIRE"
      echo "GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$CURRENT_GRIMOIRE" >> $tGRIMOIRE_LIST
      (( GRIMOIRE_COUNT++ ))
    fi

  done

  lock_commit_transaction $GRIMOIRE_LIST

  unset GRIMOIRE_DIR
  .  $GRIMOIRE_LIST 

}

#
#---------------------------------------------------------------------
## @param grimoire 
## @param [position] 
## @param [overwrite]
## 
## Adds the specified grimoire to the list of grimoires.  If no 
## position is given, the grimoire is added to the end of the list.
## Position is 0 based.  Adding a grimoire to position 0 places it as
## the first grimoire in the list, and moves all other grimoires down
## one spot, unless [<overwrite>] is set to "overwrite".
##
## This function does not currently delete duplicate entries.
##
#---------------------------------------------------------------------
function codex_add_grimoire() {
  local  NEW_GRIMOIRE=$1
  local  POSITION=$2
  local  OVERWRITE=$3
  local  GRIMOIRES=`codex_get_all_grimoires`

  touch  $GRIMOIRE_LIST
  tGRIMOIRE_LIST=`lock_start_transaction $GRIMOIRE_LIST`
#  cp     $GRIMOIRE_LIST  $GRIMOIRE_LIST_BACKUP
  rm  -f $tGRIMOIRE_LIST   
  
  local  LAST_POSITION=true
  local  CURRENT_GRIMOIRE
  local  GRIMOIRE_COUNT=0

  if [ "$OVERWRITE" == "overwrite"  ]; then

    for  CURRENT_GRIMOIRE  in  $GRIMOIRES;  do
      if [ -n "$POSITION"  ]; then
       if [  $POSITION -eq $GRIMOIRE_COUNT  ]; then
         echo GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$NEW_GRIMOIRE >> $tGRIMOIRE_LIST
         (( GRIMOIRE_COUNT++ ))
       else
         echo GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$CURRENT_GRIMOIRE >> $tGRIMOIRE_LIST
         (( GRIMOIRE_COUNT++ ))
       fi
      else
       echo GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$CURRENT_GRIMOIRE >> $tGRIMOIRE_LIST
       (( GRIMOIRE_COUNT++ ))
      fi 
    done

  else
  
    for  CURRENT_GRIMOIRE  in  $GRIMOIRES;  do
    
      if  [  -n  "$POSITION"  ];  then
        if  [  $POSITION  -eq  $GRIMOIRE_COUNT  ];  then
          echo GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$NEW_GRIMOIRE >> $tGRIMOIRE_LIST
          LAST_POSITION=false
          (( GRIMOIRE_COUNT++ ))
        fi
      fi

      if  [  "$CURRENT_GRIMOIRE"  !=  "$NEW_GRIMOIRE"  ];  then
       echo  GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$CURRENT_GRIMOIRE  >>  $tGRIMOIRE_LIST
       (( GRIMOIRE_COUNT++ ))
      fi

    done
  
    if [  "$LAST_POSITION" == "true"  ]; then
      echo  GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$NEW_GRIMOIRE  >>  $tGRIMOIRE_LIST
    fi

  fi

  lock_commit_transaction $GRIMOIRE_LIST
  unset GRIMOIRE_DIR
  .  $GRIMOIRE_LIST 

  if [ "$OVERWRITE" == "overwrite"  ]; then
    codex_remove_duplicates
  fi

}


#---------------------------------------------------------------------
## @param grimoire
## 
## Removes the specified grimoire from the list of grimoires.  
##
#---------------------------------------------------------------------
function codex_remove_grimoire() {
  local  GRIMOIRE_TO_DELETE="$1"
  local  GRIMOIRES=`codex_get_all_grimoires`

  tGRIMOIRE_LIST=`lock_start_transaction $GRIMOIRE_LIST`
  touch  $GRIMOIRE_LIST
  cp     $GRIMOIRE_LIST  $GRIMOIRE_LIST_BACKUP
  rm  -f $tGRIMOIRE_LIST   

  local  CURRENT_GRIMOIRE
  local  GRIMOIRE_COUNT=0
  for  CURRENT_GRIMOIRE  in  $GRIMOIRES  $NEW_GRIMOIRE;  do
    if  [  "$CURRENT_GRIMOIRE"  !=  "$GRIMOIRE_TO_DELETE"  ];  then
      echo  GRIMOIRE_DIR[$GRIMOIRE_COUNT]=$CURRENT_GRIMOIRE  >>  $tGRIMOIRE_LIST
    fi  
    (( GRIMOIRE_COUNT++ ))
  done

  lock_commit_transaction $GRIMOIRE_LIST
  unset GRIMOIRE_DIR
  .  $GRIMOIRE_LIST 
}


#---------------------------------------------------------------------
## @param grimoire name | grimoire dir ....
## 
## Unsets the list of grimoires that existed before the call, then
## sets the lists of grimoires to be equal to the list of grimoires
## in the argument list.  For each grimoire name, adds 
## CODEX_ROOT/<grimoire name> to the list of grimoires.  For each
## grimoire directory, adds <grimoire dir> to the list of grimoires.
##
#---------------------------------------------------------------------
function codex_set_grimoires() {
  unset GRIMOIRE_DIR
  # We need to be somewhere empty because if the user put in "test"
  # for the grimoire name and we happen to be in a directory where
  # that is a valid subdirectory things act stupidly.
  pushd "/var/empty" >/dev/null

  local  NEW_GRIMOIRE
  for    NEW_GRIMOIRE  in  "$*";  do

    if  [  -d  $NEW_GRIMOIRE  ];  then
      GRIMOIRE_DIR[${#GRIMOIRE_DIR}]=$NEW_GRIMOIRE
    else
      
      GRIMOIRE_DIR[${#GRIMOIRE_DIR}]=$CODEX_ROOT/$NEW_GRIMOIRE
    fi 

  done
  popd >/dev/null
}


#---------------------------------------------------------------------
##
## @Stdout all grimoires in the codex. 
##
#---------------------------------------------------------------------
function codex_get_all_grimoires() {
  debug "libcodex" "codex_get_all_grimoires()"
  echo "${GRIMOIRE_DIR[*]}" | tr '[:blank:]' '\n'
  return $?
  local GRIMOIRE=0
  while [ $GRIMOIRE -lt ${#GRIMOIRE_DIR[@]} ]; do
    echo "${GRIMOIRE_DIR[$GRIMOIRE]}"
    let ++GRIMOIRE
  done
}



#---------------------------------------------------------------------
## @param grimoire name
## @Stdout the grimoire's path
## @return 0 there is a grimoire
## @return 1 there is no grimoire
## <pre>
## example:
## codex_find_grimoire_by_name xfce; echo "returned $?"
## /var/lib/sorcery/codex/xfce
## returned 0
## </pre>
##
#---------------------------------------------------------------------
function codex_find_grimoire_by_name() {
  local grimoire
  
  for grimoire in $(codex_get_all_grimoires); do 
        name=$(basename $grimoire)
        if [[ $1 == $name ]]; then 
                echo $grimoire
                return 0
        fi
  done

  return 1
}



#---------------------------------------------------------------------
## @param grimoire
## 
## @Stdout Lists all section names in the specified grimoire.
## Relies on a wider-scope function <@function codex_get_sections>.
##
#---------------------------------------------------------------------
function codex_get_section_names() {
  codex_get_sections "$1" | get_basenames
}


#---------------------------------------------------------------------
## @param grimoire
##
## @Stdout Lists all sections in the specified grimoire directory.
##
#---------------------------------------------------------------------
function codex_get_sections() { 
  debug "libcodex" "codex_get_sections() - $@"

  codex_check_cache $1

  local GRIMOIRE="$1"
  
  cut -d' ' -f2 $GRIMOIRE/$SPELL_INDEX_FILE | sort | uniq
  
}


#---------------------------------------------------------------------
## @param section
##
## @Stdout full path to the section
## Given a valid section name, this function lists the full path to 
## the section.  If an invalid section name is provided, nothing is 
## listed.
##
#---------------------------------------------------------------------
function codex_find_section_by_name() {
  local SECTION_NAME="$1"
  local GRIMOIRE=''
  
  function lc311()
  {
    if [ -d "$1/$SECTION_NAME" ] ; then

      debug "libcodex" "codex_find_section_by_name() - found section $1/$SECTION_NAME"
      echo "$1/$SECTION_NAME"
      BREAK="y"
    fi
    
  }    
  iterate "lc311" $'\n' `codex_get_all_grimoires`
}


#---------------------------------------------------------------------
##
## @Stdout all section names from all grimoires.
##
#---------------------------------------------------------------------
function codex_get_all_section_names() {
  codex_get_all_sections | get_basenames
}


#---------------------------------------------------------------------
## @param grimoire-pathes (optional)
##
## @Stdout all sections from all grimoires or only from the specified grimoires.
##
#---------------------------------------------------------------------
function codex_get_all_sections() {

  if [[ $# -gt 0 ]]; then
        iterate "codex_get_sections" $'\n' $@
  else
        iterate "codex_get_sections" $'\n' `codex_get_all_grimoires`
  fi


}


#---------------------------------------------------------------------
## @param directory
##
## @return 0 if the specified directory is a spell directory.
## @return 1 otherwise
##
#---------------------------------------------------------------------
function codex_is_directory_a_spell() {
  [ -x "$1/DETAILS" ]
}


#---------------------------------------------------------------------
## @param spell 
## @param [spell ...]
##
## @return 0 if all the specified spells exist
## @return 1 othterwise
##
#---------------------------------------------------------------------
function codex_does_spell_exist() {

  local i
  local retValue=0
  for i in $* ; do
    if ! [[ `codex_find_spell_by_name $i` ]] ; then
      message "${SPELL_COLOR}$i${PROBLEM_COLOR} is not a spell!${DEFAULT_COLOR}"
	  retValue=1
    fi
  done
 
  return $retValue
 
}


#---------------------------------------------------------------------
## @param servicename
## @return 0 if service exists
## @return 1 otherwise
## checks if servicename exists.
#---------------------------------------------------------------------
function codex_does_service_exist()
{
   local SERVICE="$@" 
    for GRIMOIRE in $(codex_get_all_grimoires); do
        grep -qE '^'$SERVICE' ' "$GRIMOIRE/$PROVIDE_INDEX_FILE" && return 0
    done
}   


#---------------------------------------------------------------------
## @param spell name
## @Stdout spell name
## Given a valid spell name, this function lists the full path to the 
## spell.  If an invalid spell name is provided, nothing is listed.
##
#---------------------------------------------------------------------
function codex_find_spell_by_name() {

  debug "libcodex" "codex_find_spell_by_name - $*"
  
  codex_cache_spell_lookup $1 `codex_get_all_grimoires`
  
}


#---------------------------------------------------------------------
## @param path/section
##
## @Stdout spells
## Lists all spells in the specified section.  Nothing is listed if 
## the section doesn't include any spells.
##
#---------------------------------------------------------------------
function codex_get_spells() {

  debug "libcodex" "codex_get_spells - $*"

  local section=`basename $1`
  local index="`dirname $1`/$SPELL_INDEX_FILE"
  if ! [ -r $index ] ; then
    message "${PROBLEM_COLOR}${section:-<null>} is not a section directory!${DEFAULT_COLOR}"
    return  
  fi
  grep "/$section$" "$index" | awk '{ printf("%s/%s\n",$2,$1); }'

}


#---------------------------------------------------------------------
## @param path/section
##
## @Stdout spells 
## Lists all spell names in the specified section.  Nothing is listed 
## if the section doesn't include any spells.
## 
#---------------------------------------------------------------------
function codex_get_spell_names() {
  codex_get_spells "$1" | get_basenames
}


#---------------------------------------------------------------------
## @param  grimoire-pathes (optional)
##
## @Stdout spells
## Lists all spells in all grimoires or only from the specified 
## grimoires. Nothing is listed if no spells exist in any of grimoires. 
##
##
## NOTE: This should be fixed so only the first of duplicate spells 
##  are listed.
##
#---------------------------------------------------------------------
function codex_get_all_spells() {

  iterate "codex_get_spells" $'\n' `codex_get_all_sections $@ | grep -v "is not a"`
  
}


#---------------------------------------------------------------------
## @param spell name
##
## @Stdout spell name
## Lists the section of the given spell name.  Nothing is listed if 
## there are no spells with the given name.
##
#---------------------------------------------------------------------
function codex_get_spell_section() {
  codex_find_spell_by_name "$1" | get_dirnames
}


#---------------------------------------------------------------------
## @param spell name
##
## @Stdout section name
##
## Given a spell name, this function lists the section name.  If there
## are no spells with the given name, nothing is listed.
##
#---------------------------------------------------------------------
function codex_get_spell_section_name() {
  codex_get_spell_section "$1" | get_basenames
}


#---------------------------------------------------------------------
## @param spell or section name
## @Globals CODEX_FOUND_SECTION CODEX_FOUND_SPELL
## @return 0 if the passed argument is a spell name or a section name.
## @return 1 otherwise
## CODEX_FOUND_SECTION is set if section was found
## CODEX_FOUND_SPELL   is set if a spell was found
##
#---------------------------------------------------------------------
function codex_find_spell_or_section_by_name()  {
    local SPELL_OR_SECTION="$1"

    CODEX_FOUND_SECTION=
    CODEX_FOUND_SPELL=

    CODEX_FOUND_SECTION=`codex_find_section_by_name $SPELL_OR_SECTION`
    [  -n  "$CODEX_FOUND_SECTION"  ]  &&  return

    CODEX_FOUND_SPELL=`codex_find_spell_by_name $SPELL_OR_SECTION`
    [  -n  "$CODEX_FOUND_SPELL"  ]    &&  return

    false
}


#---------------------------------------------------------------------
## 
## @Globals GRIMOIRE SECTION SECTION_DIRECTORY SPELL SPELL_DIRECTORY SCRIPT_DIRECTORY SPELL_DESCRIPTION VERSION SHORT UPDATED SOURCE WEB_SITE ENTERRED MAINTAINER MD5 LICENSE
## Unets all these global variables. 
##
#---------------------------------------------------------------------
function codex_clear_current_spell()  {
  unset GRIMOIRE SECTION SECTION_DIRECTORY SPELL 
  unset SPELL_DIRECTORY SCRIPT_DIRECTORY SPELL_DESCRIPTION
  unset VERSION SHORT UPDATED SOURCE WEB_SITE ENTERRED MAINTAINER
  unset MD5 LICENSE BUILD_API
}


#---------------------------------------------------------------------
## @param spell directory
## @Globals All vars set in a spell
## Sets the GRIMOIRE, SECTION, SECTION_DIRECTORY, SPELL_DIRECTORY, 
## SCRIPT_DIRECTORY, and SPELL_DESCRIPTION global variables for the 
## given spell directory.
##
## Assumes the directory passed in is a valid spell directory.
##
#---------------------------------------------------------------------
function codex_set_current_spell()  {

  debug "libcodex" "runing codex_set_current_spell"
  codex_clear_current_spell
  SPELL_DIRECTORY=$1

  # Directories
  SCRIPT_DIRECTORY=$SPELL_DIRECTORY
  SECTION_DIRECTORY=`dirname $SPELL_DIRECTORY`
  GRIMOIRE=`dirname $SECTION_DIRECTORY`

  # Names
  SECTION=`basename $SECTION_DIRECTORY`
  SPELL=`basename $SPELL_DIRECTORY`
  
  SPELL_CONFIG="$DEPENDS_CONFIG/$SPELL"
  if  [ -f  $SPELL_CONFIG  ]; then
    .  $SPELL_CONFIG > /dev/null  2> /dev/null
  fi

  debug "libcodex" "looking around for API_VERSION"
  [[ -x $GRIMOIRE/API_VERSION ]] && . $GRIMOIRE/API_VERSION
  [[ -x $SECTION_DIRECTORY/API_VERSION ]] && . $SECTION_DIRECTORY/API_VERSION

  debug "libcodex" "sourcing DETAILS"
  persistent_load
  .  $SPELL_DIRECTORY/DETAILS 1>/dev/null 2>&1
  persistent_clear

  # set a default build api if there isn't one already
  # this isn't strictly necessary as other code should be able to handle the
  # lack of this variable, but I want to play it safe.
  [[ -z $BUILD_API ]] && BUILD_API=1
  true
}


#---------------------------------------------------------------------
## @param spell name
## Sets the GRIMOIRE, SECTION, SECTION_DIRECTORY, SPELL_DIRECTORY, 
## SCRIPT_DIRECTORY, and SPELL_DESCRIPTION global variables for the 
## given spell name.
## 
## @return 1 if the given name is not a spell.
##
#---------------------------------------------------------------------
function codex_set_current_spell_by_name()  {
  debug "libcodex" "codex_set_current_spell_by_name -- $1"
  local SPELL_NAME=`codex_find_spell_by_name "$1"`
  debug "libcodex" $SPELL_NAME

  [  -n  "$SPELL_NAME"  ]  &&  codex_set_current_spell  $SPELL_NAME
}


#---------------------------------------------------------------------
## @param spell directory
## @Stdout spell description 
## Echos the long description of the given spell.  Returns an
## empty string if the directory is not a valid spell.
##
#---------------------------------------------------------------------
function codex_get_spell_description()  {
  codex_is_directory_a_spell  "$1"  &&  .  "$1/DETAILS"
}

#---------------------------------------------------------------------
## @param spell directory
## @Stdout keywords
## Echos the keywords of the given spell.  Returns an
## empty string if the directory is not a valid spell.
##
#---------------------------------------------------------------------
function codex_get_spell_keywords()  {
  if codex_is_directory_a_spell  "$1"; then
    if [ -e "$1/KEYWORDS" ]; then 
      cat  "$1/KEYWORDS"
    fi
  fi
}

#---------------------------------------------------------------------
## @param spell 
## @param grimoire-path 
## @param [grimoire-path ...]
## @return 0 Spell found
## @return 1 Spell not found
## Searches the indicies of the specified grimories for a spell.
## This will return only the first match found.
##
#---------------------------------------------------------------------
function codex_cache_spell_lookup()  {

	local SECTION=""
	local spell="$1"
	shift

	while [ $# -gt 0 ] ; do
	        debug "libcodex" "looking up $spell in ${1}'s cache"
	
		codex_check_cache $1
	
		SECTION=`grep -m 1 "^$spell " $1/$SPELL_INDEX_FILE | cut -d' ' -f2`
		[[ $SECTION ]] && echo "$SECTION/$spell" && return
	
		shift
	done
	
	return 1

}

#---------------------------------------------------------------------
## @param grimoire-path
## @Stdout error if cache doesn't exist after creation
## Checks that the cache exists. if it doesn't exist, make it.
## If it still doesn't exist, the barf an error
##
#---------------------------------------------------------------------
function codex_check_cache()  {

    if ! [ -f $1/$SPELL_INDEX_FILE ] || ! [ -f $1/$PROVIDE_INDEX_FILE ]; then
        codex_create_cache
    fi
	if ! [ -f $1/$SPELL_INDEX_FILE ] || ! [ -f $1/$PROVIDE_INDEX_FILE ]; then
		message "${PROBLEM_COLOR}Eeek, $2 is not a grimoire!${DEFAULT_COLOR}" >&2
		exit 1
	fi
}

#---------------------------------------------------------------------
## @param [grimoire-path]
## Creates the cache/index for the specified grimoire, or all if none
## is asked for.
##
#---------------------------------------------------------------------
function codex_create_cache()  {
	
	debug "libcodex" "codex_create_cache - $*"
	local list="$*"
	[[ $list ]] || list="${GRIMOIRE_DIR[*]}"

	for i in $list ; do
        codex_find_in_grimoire $i "DETAILS" | \
			sed 's@\(.*\)/\([^/]*\)/DETAILS@\2 \1@' |	\
			sort > $i/$SPELL_INDEX_FILE

        codex_list_provides $i > "$i/$PROVIDE_INDEX_FILE"
	done

}



#---------------------------------------------------------------------
## @param grimoire-path 
## @param file-name
##
## @Stdout file names
## Prints every file matching file-name in grimoire
##
#---------------------------------------------------------------------
function codex_find_in_grimoire () {
    find "$1" -follow -perm +700 -maxdepth 3 -mindepth 3 -name "$2"
}



#---------------------------------------------------------------------
## @param grimoire-path
## @Stdout provides spell
## Lists all providers in grimoire in the form of "provides spell"
## for instance: <br>
## shell /home/martin/p4/grimoire/shell-term-fm/sash
## 
#---------------------------------------------------------------------
function codex_list_provides () {
    grimoire=$1

    for file in $(codex_find_in_grimoire $grimoire "PROVIDES"); do
        spell=$(dirname $file)
        for provides in $(gawk '{if (/provides/) { print $2 } 
                                 else { print $1 }}' $file); do
            echo "$provides $spell"
        done
    done | sort
}



#---------------------------------------------------------------------
##
## Mounts the codex into a tmpfs
##
#---------------------------------------------------------------------
function codex_tmpfs_mount_codex() {
  debug  "libcodex" "Running codex_mount_tmpfs()"

  if  [  -n  "$TMPFSCODEX"  ];  then
    
    [  !  -d  "$TMPFSCODEX"  ]  &&  mkdir  -p  $TMPFSCODEX
	  
    # Find out how much space to create for the temporary filesystem.
    # Add 1M to be on the safe side.
    let  $((size=`du  -hs  $CODEX  |  cut  -f1`  +  102400))
    # Find out how many inodes to reserve for tmpfs
    # Add 100 to be on the safe side.
    let  $((inodes=`find  $CODEX  |  wc  -l`  +  100))

    rm  -f  $WORKCODEX

    mount  -o  size=$size,nr_inodes=$inodes  -t  tmpfs  tmpfs  $TMPFSCODEX  &&
    cp  -R  $CODEX  $TMPFSCODEX  >  /dev/null  2>&1
    ln  -s  $TMPFSCODEX  $WORKCODEX

  fi
}


#---------------------------------------------------------------------
##
## Unmounts the codex from tmpfs
##
#---------------------------------------------------------------------
function codex_umount_tmpfs() {
  debug  "libcodex" "Running codex_umount_tmpfs()"

  umount  $TMPFSCODEX  2>  /dev/null

  rm  -f  $WORKCODEX

  rmdir   $TMPFSCODEX

  ln  -s  $CODEX  $WORKCODEX

}


#---------------------------------------------------------------------
##
## Syncs the codex in tmpfs with the one on the harddrive
##
#---------------------------------------------------------------------
function codex_resync_tmpfs() {
  debug  "libcodex" "Running codex_resync_tmpfs()"

  umount  $TMPFSCODEX                                                     &&
  mount  -o  size=$size,nr_inodes=$inodes  -t  tmpfs  tmpfs  $TMPFSCODEX  &&
  cp  -R  $CODEX  $TMPFSCODEX  >  /dev/null  2>&1
}


#---------------------------------------------------------------------
##
## @License
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
