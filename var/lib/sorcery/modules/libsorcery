#!/bin/bash
#---------------------------------------------------------------------
##
## @Synopsis Set of functions used by the internal sorcery scripts
##
## This should really be home to things related to the sorcery script
## itself, not a repository for other functions. (Andrew 5/29/04)
##
## @Copyright Additions/Corrections Copyright 2002, 2014 by the Source Mage Team
## @Copyright Original version Copyright 2001 by Kyle Sallee
##
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## @param branch
##
## Updates the sorcery scripts to their latest version for specified
## branch.
##
#---------------------------------------------------------------------
update_sorcery_scripts() {

  local BRANCH=$1

  debug "libsorcery" "update_sorcery_scripts() (sorcery-$BRANCH)"

  {
    #This section is to make sure that all sorcery dependencies are cast
    #Keep this outer if until basesystem is in the grimoires properly.
    #(2002/10/13)
    if [[ $(codex_find_spell_by_name basesystem) ]] ; then
      if ! spell_ok basesystem  ; then
        cast basesystem
      fi &&
      if [[ "$UPDATEFIX" == on ]] ; then
        cleanse --fix basesystem
      fi
      if [[ $? != 0 ]] ; then
        query "Would you like to continue anyway?" y || return 1
      fi
    fi
  }

  pushd $TMP_DIR &>/dev/null
  # sorcery is not a spell
  # there is no spoon
  SOURCE=sorcery-$BRANCH.tar.bz2
  SOURCE_DIRECTORY=$BUILD_DIRECTORY/sorcery
  SOURCE_URL=$SORCERY_URL/$SOURCE

  message  "${MESSAGE_COLOR}Downloading source file"       \
           "${FILE_COLOR}${SOURCE}${DEFAULT_COLOR}"     \
           "for sorcery update."
  url_download "$SOURCE" "$SOURCE_URL" "" "sr_target" "sr_type" || {
    message "${PROBLEM_COLOR}Failed to download sorcery${DEFAULT_COLOR}"
    return 1
  }
  if [[ $sr_type != file ]] ; then
    message "Downloaded type is not a file, file a bug if you see this"
    return 1
  fi
  [[ $sr_target != $SOURCE ]] && mv $sr_target $SOURCE

  gpg_verify_sorcery $SOURCE $SORCERY_URL
  rc=$?

  gpg_user_query $rc $SORCERY_BRANCH sorcery || return 1
  popd &>/dev/null

  local FILENAME=$TMP_DIR/$SOURCE
  # copy the tarball to /var/spool/sorcery after we've downloaded and
  # verified it.
  ensure_dir "$SOURCE_CACHE"
  cp $FILENAME $SOURCE_CACHE

  mk_source_dir  $SOURCE_DIRECTORY              &&
  cd $BUILD_DIRECTORY
  # untar is defined by libunpack
  bzip2 -dc < "$FILENAME" | untar                &&
  cd      $SOURCE_DIRECTORY                     &&

  pwd                                           || return 1

  # last chance to lock
  message -n "${MESSAGE_COLOR}Waiting for${DEFAULT_COLOR} ${SPELL_COLOR}all${DEFAULT_COLOR}" \
             "${MESSAGE_COLOR}spells to complete...${DEFAULT_COLOR}"
  lock_resources "solo" "cast" # prevent other casts
  excllock_resources "cast" "sorcery" # wait for other casts
  message "done."
  lock_resources "libgrimoire" "install"      &&

  if test -x ./uninstall && test -f /etc/sorcery/install.log ; then
    message uninstalling...
    ./uninstall
  else
    # rough equivalent to prepare_install...
    rm /etc/sorcery/* 2>/dev/null
    rm /etc/sorcery/licenses/*   2>/dev/null
    rm /etc/sorcery/mirrors/* 2>/dev/null
    rm /var/lib/sorcery/* 2>/dev/null
    rm -r /var/lib/sorcery/modules/* 2>/dev/null
    rm -r /var/lib/sorcery/archspecs/* 2>/dev/null
    rm -r /var/lib/sorcery/build/* 2>/dev/null
  fi
  ./install                                     &&

  cd /                                          &&
  unlock_resources "libgrimoire" "install"      &&

  SORCERY_VERSION=$(cat /etc/sorcery/version)

  unlock_resources "solo" "cast"
  unlock_resources "cast" "sorcery"

  if [ $? -eq 0 ] ; then
    activity_log "update" "sorcery-$BRANCH" "$SORCERY_VERSION" "success"
    rm_source_dir
  else
    activity_log "update" "sorcery-$BRANCH" "$SORCERY_VERSION" "failure"
    if [[  $CLEAN_SOURCE == on ]]; then
      rm_source_dir
    fi
  fi
  message "${MESSAGE_COLOR}Current" \
          "${SPELL_COLOR}sorcery-$BRANCH${DEFAULT_COLOR} ${MESSAGE_COLOR}version" \
          "${VERSION_COLOR}$SORCERY_VERSION${DEFAULT_COLOR}"
  echo
  sorcery_history
  rm $FILENAME
}

#---------------------------------------------------------------------
##
## Menu query to user asking to set the nice value which sorcery should
## use to run proccesses at.
##
#---------------------------------------------------------------------
set_nice()  {

  PROMPT="Please enter the process priority sorcery should run at."

  if  NICE=$(eval $DIALOG '  --ok-label  "Commit"  \
                            --inputbox            \
                            "$PROMPT"             \
                            0 0  "$NICE"')
  then
     modify_local_config "NICE" "$NICE"
  fi

}

#---------------------------------------------------------------------
##
## Menu query to user asking to set the umask value which sorcery should
## use to run proccesses with.
##
#---------------------------------------------------------------------
set_umask()  {

  PROMPT="Please enter the permissions mask sorcery should run with."

  if  UMASK=$(eval $DIALOG '  --ok-label  "Commit"  \
                            --inputbox            \
                            "$PROMPT"             \
                            0 0  "$UMASK"')
  then
     modify_local_config "UMASK" "$UMASK"
  fi

}


#---------------------------------------------------------------------
## @param filename
##
## Displays and the contents of the file given as the first argument.
##
#---------------------------------------------------------------------
report() {
  if  !  [  -f  $1  ];  then  return;  fi

  run_hook REPORT
  if  [  "$VIEW_REPORTS"  ==  "on"  ];  then

    debug  "libsorcery" "Prompting to view $2 for $SPELL"

    VIEW_PROMPT="View $2 for ${SPELL_COLOR}${SPELL}-${VERSION_COLOR}${VERSION}${DEFAULT_COLOR}?"
    if  query  "$VIEW_PROMPT" n;  then  $PAGER  $1;  fi
  fi

  true

}


#---------------------------------------------------------------------
## @param filename
##
## Given a filename, will return the actual filename if a similar
## filename with a different extension exists.
##
#---------------------------------------------------------------------
guess_filename()  {

  local filename=$1

  debug "libsorcery" "Running guess_filename() on $filename"

  if [[ -f  $filename ]]; then
    echo $filename
  else
    # currently only used from gaze
    if [[ $FUZZ != on ]]; then
      return 1
    else
      local basename=$(sed -r "s/\.(tar\.(gz|bz2)|tgz|gz|bz2)$//" <<< "$filename")
      local extension
      for extension in tar.gz tar.bz2 tgz gz bz2; do
        if [[ -f $basename.$extension ]]; then
          echo $basename.$extension
          return 0
        fi
      done
      return 1
    fi
  fi

}

#-------------------------------------------------------------------------
## check if the file exists, or one with a similar compression exists
## @param file
#-------------------------------------------------------------------------
file_exists()  {
  guess_filename  $1  >  /dev/null
}

#---------------------------------------------------------------------
##
## Saves the current libraries associated with the spell, from /lib
## and /usr/lib into $SOURCE_DIRECTORY/old.libraries/
## Also runs ldconfig with the saved libraries.
##
#---------------------------------------------------------------------
save_libraries()  {

  if    [  -z  "$SOURCE_DIRECTORY"  ]
  then  return
  fi

  debug  "libsorcery" "Running save_libraries()"

  OLD_LIBS=$SOURCE_DIRECTORY/old.libraries
  mkdir -p "$OLD_LIBS"

  SAVED=$OLD_LIBS/$SPELL.saved.libraries
  lock_file "$SAVED"
  rm -rf "$SAVED"

  OLD_VERSION=$(installed_version  $SPELL)
      OLD_LOG=$INSTALL_LOGS/$SPELL-$OLD_VERSION

  grep "^/lib/\|^/usr/lib" "$OLD_LOG" |
  while  read        LINE;  do
    if [[ -f $LINE ]] &&
         file -bL "$LINE" |
         grep  -q   "shared object"
    then
      if [[ -h $LINE ]]; then
        local DEST=$(readlink "$LINE")
        ln -sf "$DEST" "$OLD_LIBS/$(smgl_basename "$LINE")"
      else
        cp "$LINE" "$OLD_LIBS"
      fi
      echo $OLD_LIBS/$(smgl_basename "$LINE") >> "$SAVED"
    fi


  done

  case "$HOST" in *-gnu) ldconfig "$OLD_LIBS";; esac
  unlock_file "$SAVED"

  if  [  -z   "$LD_LIBRARY_PATH"  ]
  then  export  LD_LIBRARY_PATH="$OLD_LIBS"
  else  export  LD_LIBRARY_PATH="$OLD_LIBS:$LD_LIBRARY_PATH"
  fi

}

#---------------------------------------------------------------------
##
## Saves the current libraries associated with the spell, from /lib
## and /usr/lib into $SOURCE_DIRECTORY/old.libraries/
## Also runs ldconfig with the saved libraries.
##
#---------------------------------------------------------------------
save_binaries()  {
  local dir
  if    [  -z  "$SOURCE_DIRECTORY"  ]
  then  return
  fi

  debug  "libsorcery" "Running save_binaries()"

  OLD_BINS=$SOURCE_DIRECTORY/old.binaries
  mkdir -p "$OLD_BINS"

  SAVED=$OLD_BINS/$SPELL.saved.binaries
  lock_file "$SAVED"
  rm -rf "$SAVED"

  OLD_VERSION=$(installed_version  $SPELL)
      OLD_LOG=$INSTALL_LOGS/$SPELL-$OLD_VERSION

  grep "^/bin/\|^/sbin/\|^/usr/bin/\|^/usr/sbin/" "$OLD_LOG" |
  while  read        LINE;  do
    if [[ -f $LINE ]] &&
         file -bL "$LINE" |
         grep  -q   "executable"
    then
      mkdir -p "$( smgl_dirname "$OLD_BINS/$LINE" )"
      if [[ -h "$LINE" ]]; then
        DEST=$( readlink "$LINE" )
        ln -sf "$DEST" "$OLD_BINS/$LINE"
      else
        cp "$LINE" "$OLD_BINS/$LINE"
      fi
      echo $OLD_BINS/$LINE >> "$SAVED"
    fi
  done

  unlock_file "$SAVED"

  for dir in $(find "$OLD_BINS" -type d)
  do
    export PATH=$(envar_prepend_path "$dir" "$PATH")
  done
}


#---------------------------------------------------------------------
##
## Runs default ldconfig to stop using the saved libraries
##
#---------------------------------------------------------------------
release_saved_libraries()  {
  case "$HOST" in *-gnu) ldconfig;; esac
}


#---------------------------------------------------------------------
##
## Recovers from a CTRL-C while casting a spell
##
#---------------------------------------------------------------------
spell_recover()  {

  debug  "libsorcery" "Running spell_recover()"

  message  "${MESSAGE_COLOR}Aborting dispel of ${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
           "${MESSAGE_COLOR}and recovering...${DEFAULT_COLOR}"

  unlock_resources "libgrimoire" "install"
  unlock_resources "cast" "$SPELL"
  unlock_resources "solo" "cast"
  local current_version=$(installed_version $SPELL)
  SUCCESS_LIST=/dev/null
  resurrect_spell $SPELL $current_version

  exit  130
}


#---------------------------------------------------------------------
## @param spell name
## @Stdout section
## Returns the section a spell is in.
##
#---------------------------------------------------------------------
find_section()  {

  debug  "libsorcery" "Running find_section() on $1"

  codex_get_spell_section_name  $1

}


#---------------------------------------------------------------------
##=item directories
##
## @Stdin list of files/dirs/..
## @Stdout list of dirs
##
## Reads a list from standard input, and prints out each entry that is
## a directory (and not a symbolic link to a directory).
#---------------------------------------------------------------------
directories() {
  local item
  while read item; do
    if [[ -d $item ]] && ! [[ -h $item ]]; then
      echo "$item"
    fi
  done
}


#---------------------------------------------------------------------
## @Stdin list of files/dirs/..
## @Stdout list of files
## Reads a list from standard input, and prints out each entry that is
## a file (and not a symbolic link to a file).
##
#---------------------------------------------------------------------
files()  {
  local item
  while read item; do
    if [[ -f $item ]] && ! [[ -h $item ]]; then
      echo "$item"
    fi
  done
}


#---------------------------------------------------------------------
## @Stdin list of files/dirs/..
## @Stdout list of symlinks
## Reads a list from standard input, and prints out each entry that is
## a symbolic linke
##
#---------------------------------------------------------------------
symlinks()  {
  local item
  while read item; do
    if [[ -h $item ]]; then
      echo "$item"
    fi
  done
}


#---------------------------------------------------------------------
## @param filename
## @Stdin list of files/dirs/..
## @Stdout filtered list
## First argument is a file that contains (basic) grep regular expressions.
## They are joined with \|'s and given to grep -v.
## Which will filter standard input to remove entries that match.
## Used to filter out excluded or protected files from install logs.
##
#---------------------------------------------------------------------
filter() {
  local thing RID_LIST NOT_RID_LIST
  local files each invert
  for each in $@; do
    test -f $each && files="$files $each"
  done

  if [[ $files ]] ; then
    RID_LIST=$(
      cat $files   |
      grep -v '^!' | while read thing; do
                       echo -n "${thing}\|"
                     done)
    NOT_RID_LIST=$(
      cat $files   |
      grep '^!'    | while read thing; do
                       echo -n "${thing/\!/}\|"
                     done)
    RID_LIST=${RID_LIST%\\|}
    NOT_RID_LIST=${NOT_RID_LIST%\\|}

    local TMP_SSF=$(make_safe_dir)
    local FILE=$TMP_SSF/ssf

    if [[ $RID_LIST ]]
    then
      if [[ $NOT_RID_LIST ]]
      then
        cat > $FILE
        {
          grep -v "$NOT_RID_LIST\|$RID_LIST" $FILE
          grep "$NOT_RID_LIST" $FILE
        }
        rm $FILE 2>/dev/null
      else
        grep -v "$RID_LIST"
      fi
    else
      cat
    fi
    rmdir $TMP_SSF 2>/dev/null
  else
    cat
  fi
}

#---------------------------------------------------------------------
## @param filename
## @Stdin list of files/dirs/..
## @Stdout filtered list
## First argument is a file that contains (basic) grep regular expressions.
## They are joined with \|'s and given to grep
## Which will filter standard input and remove entries
## that do not match.
## Used to filter in config files from install logs.
##
#---------------------------------------------------------------------
filter_in() {
  local thing RID_LIST NOT_RID_LIST
  local files each
  for each in $@; do
    test -f $each && files="$files $each"
  done

  if [[ $files ]] ; then
    RID_LIST=$(
      cat $files   |
      grep -v '^!' | while read thing; do
                       echo -n "${thing}\|"
                     done)
    NOT_RID_LIST=$(
      cat $files   |
      grep '^!'    | while read thing; do
                       echo -n "${thing/\!/}\|"
                     done)
    RID_LIST=${RID_LIST%\\|}
    NOT_RID_LIST=${NOT_RID_LIST%\\|}

    if [[ $RID_LIST ]]
    then
      if [[ $NOT_RID_LIST ]]
      then
        grep "$RID_LIST" |
        grep -v "$NOT_RID_LIST"
      else
        grep "$RID_LIST"
      fi
    else
      # grep '' outputs everything in this case we want nothing
      cat > /dev/null
    fi
  else
    cat
  fi
}

filter_generic() {
  local args=$1
  local filter_name=$2
  local system_filter=$3
  local spell_from=$4
  local grimoire_filter section_filter spell_filter spell_dir
  if [[ $spell_from == "codex" ]]
  then
    debug libsorcery "filter_generic codex at : $SCRIPT_DIRECTORY "
    grimoire_filter=$GRIMOIRE/$filter_name
    section_filter=$SECTION_DIRECTORY/$filter_name
    spell_filter=$SCRIPT_DIRECTORY/$filter_name
  else
    if tablet_find_spell_dir $SPELL spell_dir &>/dev/null; then
      debug libsorcery "filter_generic tablet at : $spell_dir "
      tablet_get_spell_filter "$spell_dir" "$filter_name" spell_filter &>/dev/null
      tablet_get_section_filter "$spell_dir" "$filter_name" section_filter &>/dev/null
      tablet_get_grimoire_filter "$spell_dir" "$filter_name" grimoire_filter &>/dev/null
    fi
  fi
  set -- $args
  if [ "$1" == -v ] ; then
    shift
    filter_in "$@" $system_filter $grimoire_filter $section_filter $spell_filter
  else
    filter "$@" $system_filter $grimoire_filter $section_filter $spell_filter
  fi
}

filter_volatiles() {
  filter_generic "$*" volatiles $VOLATILES
}

filter_configs() {
  filter_generic "$*" configs $CONFIGS
}

filter_excluded() {
  filter_generic "$*" excluded $EXCLUDED
}

filter_protected() {
  filter_generic "$*" protected $PROTECTED
}

#---------------------------------------------------------------------
## @Stdin list of files
## @Stdout list of directories
##
## THIS FUNCTION IS DEPRECIATED, use get_dirnames instead! (remove in 1.16)
## Given a list of files from standard input, returns the directory
## of each file.
#---------------------------------------------------------------------
dirnames()  {
  get_dirnames "$@"
}

#---------------------------------------------------------------------
##
## Sets some environment variables (such as C<CFLAGS>) based on the
## option passed.  Options may be on or more of:  i386, i486, i586,
## pentium, pentium-mmx, i686, pentiumpro, pentium2, pentium3,
## pentium4, k6, k6-2, k6-3, athlon, athlon-tbird, athlon-4,
## athlon-xp, athlon-mp, powerpc, speedy, tiny, risky, strip
##
#---------------------------------------------------------------------
optimize()  {
  debug "libsorcery" "In optimize()"

  unset  CFLAGS CXXFLAGS LDFLAGS CPPFLAGS
  unset  FAST PRELINK RISKY SMALL SPEEDY STRIP TINY AS_NEEDED NOSEPCODE

  # if user specified --no-opts then use only the args from the command line
  # otherwise do the normal stuff
  if [[ $NO_OPTIMIZATION_FLAGS ]] ; then
    export CFLAGS="$OVERRIDE_CFLAGS"
    export CXXFLAGS="$OVERRIDE_CXXFLAGS"
    export LDFLAGS="$OVERRIDE_LDLAGS"
    export CPPFLAGS="$OVERRIDE_CPPFLAGS"
  else
    set_architecture
    debug "libsorcery" "ARCHITECTURE='${ARCHITECTURE}'"
    debug "libsorcery" "TARGET='${TARGET}'"
    debug "libsorcery" "OPTIMIZATIONS='${OPTIMIZATIONS}'"
    BUILD=${HOST}

    debug "libsorcery" "BUILD is $BUILD, HOST is $HOST"

    CFLAGS="$CFLAGS -pipe"
    for  PARAM  in  $OPTIMIZATIONS;  do
      case  $PARAM  in
        prelink)
          CFLAGS="$CFLAGS -fPIC"
          PRELINK="on"
          ;;

        risky)
          CFLAGS="$CFLAGS -ffast-math -funroll-loops"
          RISKY="on"
          ;;

        speedy)
          CFLAGS="$CFLAGS $FAST"
          SPEEDY="on"
          ;;

        strip)
          LDFLAGS="$LDFLAGS -s"
          STRIP="on"
          ;;

        tiny)
          CFLAGS="$CFLAGS $SMALL"
          TINY="on"
          ;;

        as_needed)
          LDFLAGS="$LDFLAGS -Wl,--as-needed"
          AS_NEEDED="on"
          ;;

        nosepcode)
          LDFLAGS+=' -Wl,-znoseparate-code'
          NOSEPCODE="on"
          ;;

      esac
    done
    # use echo to crunch all the whitespace out for broken configure scripts
    export CXXFLAGS=$(echo $CFLAGS $CUSTOM_CXXFLAGS $OVERRIDE_CXXFLAGS $USER_SPELL_CXXFLAGS)
    export CFLAGS=$(echo $CFLAGS $CUSTOM_CFLAGS $OVERRIDE_CFLAGS $USER_SPELL_CFLAGS)
    export LDFLAGS=$(echo $LDFLAGS $CUSTOM_LDFLAGS $OVERRIDE_LDLAGS $USER_SPELL_LDFLAGS)
    export CPPFLAGS=$(echo $CPPFLAGS $CUSTOM_CPPFLAGS $OVERRIDE_CPPFLAGS $USER_SPELL_CPPFLAGS)
  fi

}

#---------------------------------------------------------------------
## @param grimoire-path
## @Stdout history
## Display the history of the grimoire given for review
#---------------------------------------------------------------------
grimoire_history() {

  local grimoire="$1"
  if [ -e $grimoire/ChangeLog ] ; then
    local grimoirename="${grimoire##*/}"
    local date="$(cat "$STATE_DIRECTORY/$grimoirename.lastupdate" 2> /dev/null)"
    [ -z "$date" ] && date="20030818"
    local datedash=$(echo "$date" | sed 's,^\(....\)\(..\)\(..\)$,\1-\2-\3,')
    get_new_changes "Viewing history since last update ($datedash) for grimoire --  ${grimoirename}  -- :" "$date" "$grimoire/ChangeLog"
  else
    echo  "No ChangeLog in the $grimoire Grimoire, skipping viewing..."
    echo  ""
  fi
  date +%Y%m%d > "$STATE_DIRECTORY/$grimoirename.lastupdate"
}


#---------------------------------------------------------------------
## @Stdout history
## Display the history of sorcery for review
##
#---------------------------------------------------------------------
sorcery_history() {
  local date="$(cat "$STATE_DIRECTORY/sorcery.lastupdate" 2> /dev/null)"
  [ -z "$date" ] && date="20030818"
  local datedash="$(echo "$date" | sed 's,^\(....\)\(..\)\(..\)$,\1-\2-\3,')"

  get_new_changes "Viewing history since last update ($datedash) for sorcery :"  "$date" /usr/share/doc/sorcery/ChangeLog

  date +%Y%m%d > "$STATE_DIRECTORY/sorcery.lastupdate"
}

#---------------------------------------------------------------------
##@param old date
##@param changelog
## Get the new changes from passed changelog argument
##
#---------------------------------------------------------------------
get_new_changes() {
    local msg="$1"
    local date="$2"
    local changelog="$(awk -v date="$date" -F'[- ]' -- '/^[0-9]/{if (($1 $2 $3) < date) exit}{print}' "$3")"

    if [[ "$changelog" ]] ; then
      {
        echo "$msg"
        echo "$changelog"
        echo
      }  > $TMP_DIR/pagerdata
      timeout_pager "$TMP_DIR/pagerdata"
      rm $TMP_DIR/pagerdata
    else
      echo "$msg"
      echo "Nothing new."
      echo
    fi
}


#---------------------------------------------------------------------
## Pager with timeouts, cannot be used from a pipe.
## Invokes a subshell in case there are other background jobs running
#---------------------------------------------------------------------
timeout_pager() { (
  $PAGER "$@" &
  sleep 1
  for ((i=0;i<PAGER_TIMEOUT*10;i++)) ; do
    jobs &>/dev/null # this makes bash clean up so the next line works
    [[ "$(jobs)" ]] || return 0
    sleep .1
  done
  jobs -p|xargs kill
  jobs &>/dev/null # hide the [Done [2] blah blah] message
  stty sane
  if query "\nPager timeout, continue viewing $@" n; then
    $PAGER "$@"
  fi
) 2>/dev/null # hides less complaining that it was killed
}

#---------------------------------------------------------------------
##
## Attempt to fix any spells that may be broken.
##
#---------------------------------------------------------------------
fix_installed_spells()  {

  local ANSWER=

  [  "$AUTOFIX"  ==  "on"  ]  &&  ANSWER=y  ||  ANSWER=n
  if  query  "Attempt to fix spells that may have become broken ?" $ANSWER;  then
    cleanse --fix;
  fi

  if  [  "$AUTOPRUNE"  ==  "on"  ];  then  prune;  fi
}

#---------------------------------------------------------------------
## @Stdout log files list
## Returns a list of the log files for each spell.
##
#---------------------------------------------------------------------
log_list()  {
  local spell version
  while read spell version; do
    # the install and md5sum logs are not compressed
    echo "$INSTALL_LOGS/$spell-$version"
    echo "$MD5SUM_LOGS/$spell-$version"
    # the compile and castfs log usually are compressed
    # FIXME $EXTENSION may be the wrong one if the user changed it
    echo "$COMPILE_LOGS/$spell-$version$EXTENSION"
    echo "$COMPILE_LOGS/$spell-$version.castfs.dbglog$EXTENSION"
  done < <(all_spell_status | cut -d: -f1,4 --output-delimiter=" ")
}


#---------------------------------------------------------------------
##
## Removes stale logs.
##
#---------------------------------------------------------------------
clean_logs()  {
  debug  "libsorcery" "Running clean_logs()"
  local file

  message "${CHECK_COLOR}Cleaning log files...$DEFAULT_COLOR"

  {
    # don't try to delete logs of installed spells, as they may not exist
    # tee duplicates the output, so uniq will filter them out
    log_list | sed p
    find $INSTALL_LOGS $MD5SUM_LOGS $COMPILE_LOGS -type f
  } | sort | uniq -u |
  while read file; do
    message "Removing stale log: $file"
    rm "$file"
  done
}

#---------------------------------------------------------------------
##
## Updates the activity log.
##
#---------------------------------------------------------------------
activity_log() {
  local date command spell version outcome info

  lock_file $ACTIVITY_LOG
     date=$(date -u +%Y%m%d:%H%M\(%z\))
  command=$1
    spell=$2
  version=$3
  outcome=$4
     info=$5
  echo -e "$date\t$command\t$spell\t$version\t$outcome\t$info" >> $ACTIVITY_LOG
  unlock_file $ACTIVITY_LOG
}


#---------------------------------------------------------------------
##
## Executes the spell's DETAILS file.
##
#---------------------------------------------------------------------
run_details() {
  debug "libsorcery" "starting run_details for $SPELL"
  if  !  codex_set_current_spell_by_name  $SPELL;  then
    local  GRIMOIRES=$(codex_get_all_grimoires)
    message  "${PROBLEM_COLOR}Unable to find spell"        \
             "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}${PROBLEM_COLOR}"      \
             "in grimoire(s): $GRIMOIRES ${DEFAULT_COLOR}"
    false
  fi
}

#---------------------------------------------------------------------
##
## unsets variables set by DETAILS. <br>
## vars: SPELL VERSION SOURCE_DIRECTORY WEB_SITE UPDATED ENTERED SHORT SOURCE*
##
## Needs to be merged with the libcodex function since they are both
## needed to fully unset a DETAILS (afk 4/21/04)
##
#---------------------------------------------------------------------
unset_details()  {

  local TEMP=""
  local VARS="SPELL VERSION SOURCE_DIRECTORY WEB_SITE UPDATED ENTERED SHORT"
  VARS="$VARS SECURITY_PATCH PATCHLEVEL"

  # Take care or SOURCEx and SOURCEx_URL
  for i in ${!SOURCE*} ; do
    TEMP=${TEMP}${i}\\n
  done
  # not all SOURCE_* should be deleted (SOURCE_CACHE)
  VARS="$VARS $(echo -e $TEMP | egrep "^SOURCE[0-9]*(_URL|_GPG|_IGNORE)?$")"

  unset $VARS
}




#---------------------------------------------------------------------
##
## Runs C<track> and C<archive> on the current spell.
##
## THIS FUNCTION IS DEPRECIATED AND SHOULD NOT BE CALLED FOR ANY REASON
##
#---------------------------------------------------------------------
boost() {

  debug  "libsorcery" "Running boost() on $SPELL THIS IS DEPRECIATED"
  echo "Running boost() on $SPELL THIS IS DEPRECIATED, please contact the spell's maintainer and ask them to remove this call"
  true
}


#---------------------------------------------------------------------
##
## Given a list of source files, returns true if each file exists.
##
#---------------------------------------------------------------------
verify_source() {
  local source_file
  for source_file in $@; do
    if ! guess_filename $SOURCE_CACHE/$source_file > /dev/null; then
      message  "${PROBLEM_COLOR}Missing ${FILE_COLOR}$source_file${DEFAULT_COLOR}"
      message  "${PROBLEM_COLOR}Cast aborting.${DEFAULT_COLOR}"
      activity_log  "cast"  "$SPELL"  "$VERSION"  "failure"  \
                    "because it was missing source: $source_file"
      log_failure_reason "missing source"
      return 1
    fi
  done
  return 0
}


#---------------------------------------------------------------------
## @param spell
## @Stdout filelist
## Returns a list of each source file used by a spell.  Most have only
## one, but xfree86 for example splits the sources into three separate
## source files.
##
#---------------------------------------------------------------------
sources()  { (
  while [ $# -gt 0 ]; do
    codex_set_current_spell_by_name "$1"
    get_spell_files
    shift
  done
) }

#---------------------------------------------------------------------
## @param spell...
## @Stdout filelist
## Returns a list of each source file used by a spell.  Most have only
## one, but xfree86 for example splits the sources into three separate
## source files.
##
#---------------------------------------------------------------------
source_urls()  { (
  while [ $# -gt 0 ]; do
    codex_set_current_spell_by_name "$1"
    get_spell_files_and_urls | awk '{for(i=2;i<=NF;++i)print $i}'
    shift
  done
) }


#---------------------------------------------------------------------
## @Stdout filelist
## Returns a list of files that should not be pruned.
##
#---------------------------------------------------------------------
generate_keep_list()  {
  local source_keep="$1"
  local cache_keep="$2"
  local type="$3"
  if [[ "$type" == installed_only ]] ; then
    get_all_spells_with_status ok |
    sort -u |
    while read spell; do
      codex_find_spell_by_name "$spell"
    done
  else
    codex_get_all_spells
  fi |
  (
  echo sorcery-$SORCERY_BRANCH.tar.bz2
  while read SPELL_DIRECTORY ; do
    codex_set_current_spell_quick "$SPELL_DIRECTORY" &>/dev/null
    get_spell_files 2>/dev/null
    ls $INSTALL_CACHE/$SPELL-$VERSION-* 1>&2 2>/dev/null
    unset VERSION SPELL ${!SOURCE*}
  done
  ) 2> $cache_keep > $source_keep

  #Add the README in the cache to list of files to keep
  echo  README >> $cache_keep

}


#---------------------------------------------------------------------
##
## Removes unnecessary files from the source cache and install cache.
##
#---------------------------------------------------------------------
prune()  {

  debug  "libsorcery" "Running prune()"
  local NO_KEEP
  local NUM_NO_KEEP=0

  message "${MESSAGE_COLOR}Generating list of files to keep...${DEFAULT_COLOR}"
  local SOURCE_KEEP="$TMP_DIR/prune-keep-source"
  local CACHE_KEEP="$TMP_DIR/prune-keep-cache"
  rm -rf "$CACHE_KEEP"
  rm -rf "$SOURCE_KEEP"
  generate_keep_list  "$SOURCE_KEEP" "$CACHE_KEEP" "$1"

  message "${MESSAGE_COLOR}Cleaning up source cache" \
          "(${DEFAULT_COLOR}$SOURCE_CACHE${MESSAGE_COLOR})...${DEFAULT_COLOR}"
  local SOURCE_RM="$TMP_DIR/prune.rm.source"
  find "$SOURCE_CACHE" -follow -mindepth 1 -maxdepth 1 -type f|
  awk -F/ 'BEGIN {
             while ( getline < ARGV[1] )
               keep[$NF]
             while ( getline < ARGV[2] )
               if (!($NF in keep))
                 print
           }' "$SOURCE_KEEP" - |sort -u > "$SOURCE_RM"
  if [ -s "$SOURCE_RM" ]; then
    NUM_NO_KEEP=$(< "$SOURCE_RM" wc -l)

    message "There are $NUM_NO_KEEP files that can be removed"
    if query "Edit the list?" "n" ; then
      edit_file "$SOURCE_RM"
    fi
    if query "Remove the files?" "y" ; then
      < "$SOURCE_RM" xargs rm
    fi
  fi

  message "${MESSAGE_COLOR}Cleaning up install cache" \
          "(${DEFAULT_COLOR}$INSTALL_CACHE${MESSAGE_COLOR})...${DEFAULT_COLOR}"
  local CACHE_RM="$TMP_DIR/prune.rm.cache"
  find "$INSTALL_CACHE" -mindepth 1 -maxdepth 1 -type f|
  awk -F/ 'BEGIN {
             while ( getline < ARGV[1] )
               keep[$NF]
             while ( getline < ARGV[2] )
               if (!($NF in keep))
                 print
           }' "$CACHE_KEEP" - |sort -u > "$CACHE_RM"
  if [ -s "$CACHE_RM" ]; then
    NUM_NO_KEEP=$(< "$CACHE_RM" wc -l)
    message "There are $NUM_NO_KEEP files that can be removed"
    if query "Edit the list?" "n" ; then
      edit_file "$CACHE_RM"
    fi
    if query "Remove the files?" "y" ; then
      < "$CACHE_RM" xargs rm
    fi
  fi

  rm  -f  "$SOURCE_KEEP" "$CACHE_KEEP" "$SOURCE_RM" "$CACHE_RM"

}


#---------------------------------------------------------------------
##
## Sets DISTCC=[on|off] depending on the value of DISTCC_HOSTS.
## Adds /var/lib/sorcery/build to the C<PATH> if necessary.
##
#---------------------------------------------------------------------
invoke_build_dir() {

  # This merits some explaination:
  #
  # In the /var/lib/sorcery/build dir are frontends for the compilers
  # they run CCACHE and DISTCC. By putting them in the front of the path
  # they get run first, then hand the work off to the real compilers.
  # The script also loads /etc/sorcery/compile_config, this made it
  # convenient for building stuff outside of sorcery and taking advantage
  # of ccache/distcc, just do "export  PATH="/var/lib/sorcery/build:$PATH""
  # and you're set, you can also edit the DISTCC hosts on the fly.
  #
  # Then someone had the bright idea "if we set DISTCC_HOSTS to the empty
  # string, distcc wont run!" due to a misconception in how this function
  # worked, that spell hack would only work /some/ of the time: if you
  # used ccache in addition to distcc, distcc wouldnt get disabled. *Sigh*
  #
  # SO...now we're stuck with a bunch of spells in the field disabling
  # distcc in an broken way, obviously they all cant change overnight. To
  # make matters worse inside make() we have to fiddle with the number of
  # make jobs to use in case distcc is disabled (badly).
  #
  # so the answer is:
  # 1) make a new variable "USE_DISTCC" and set it to "off" if distcc
  # is being disabled by the spell
  # 2) check if USE_DISTCC == off in run_compiler, but still check the
  # other signs just in case its being run manually
  # 3) add a check for DISABLE_DISTCC so spells can start using that someday
  #   (phase this in after a few months, then phase out the old check below,
  #   but not in run_compiler)
  # 4) remove the old stupid logic for MAKE_NJOBS (num_hosts + 1),
  # instead split MAKE_NJOBS up, add a JOBS_PER_HOST multiplier, and add
  # MAKE_NJOBS to that. This results in the number of jobs being $MAKE_NJOBS
  # (default 1) when distcc is disabled (bug 6432), and allows an automatic
  # increase in the number of jobs per host if its desired.
  #

  USE_DISTCC=off
  if [[ $DISABLE_DISTCC != yes ]] ; then
    if test -n "$DISTCC_HOSTS" && spell_ok distcc ; then
      USE_DISTCC=on
    fi
  fi

  if ! spell_ok ccache ; then
    CCACHE=off
  fi

  if [[ "$CCACHE" == on ]] || [[ "$USE_DISTCC" == on ]] ; then
    export  PATH="$RUN_COMPILER_DIR:$PATH"
  fi
}

#---------------------------------------------------------------------
## @Stdout filelist
## Returns false if one or more source files for the current spell
## are missing.
##
#---------------------------------------------------------------------
verify_sources()  {
  verify_source $(sources $SPELL)
}



#---------------------------------------------------------------------
##
## Will set the prefered compression type based on user filled option
## in dialog menu (either gzip/bzip).
##
#---------------------------------------------------------------------
set_compression_type() {

  local B_HELP="bzip2 compression (slow, small files)"
  local P_HELP="parallel bzip2 compression (slow unless on SMP, small files)"
  local X_HELP="xz compression (slow compress, fast decompress, smallest files)"
  local G_HELP="gzip compression (fast, larger files)"
  local T_HELP="no compression/tar (fastest, largest files)"

  while

    COMMAND=$(eval $DIALOG '  --title "Currently using : $COMPRESSBIN "  \
                             --item-help                                \
                             --ok-label      "Select"                   \
                             --cancel-label  "Exit"                     \
                             --menu                                     \
                             ""                                         \
                             0 0 0                                      \
                             "B"  "bzip2 compression"        "$B_HELP"  \
                             "P"  "pbzip2 compression (parallel bzip2)" "$P_HELP"  \
                             "X"  "xz compression"           "$X_HELP"  \
                             "G"  "gzip compression"         "$G_HELP"  \
                             "T"  "no compression/tar"       "$T_HELP"')

  do
    ARCHIVEBIN="tar"
    modify_local_config "ARCHIVEBIN" "tar"

    case  $COMMAND in
      B)
          modify_local_config "COMPRESSBIN" "bzip2" &&
          COMPRESSBIN="bzip2"                        &&
          modify_local_config "EXTENSION" ".bz2" ;;
      P)
          if ! spell_ok pbzip2; then
            clear_line
            message "pbzip2 is not installed on this system! Running cast ...\n"
            sleep 2
            cast pbzip2
          fi &&
          modify_local_config "COMPRESSBIN" "pbzip2"  &&
          COMPRESSBIN="pbzip2"                        &&
          modify_local_config "EXTENSION" ".bz2" ;;
      X)
          if ! spell_ok xz-utils; then
            clear_line
            message "xz-utils is not installed on this system! Running cast ...\n"
            sleep 2
            cast xz-utils
          fi &&
          modify_local_config "COMPRESSBIN" "xz"   &&
          COMPRESSBIN="xz"                         &&
          modify_local_config "EXTENSION" ".xz"    ;;
      G)
          modify_local_config "COMPRESSBIN" "gzip" &&
          COMPRESSBIN="gzip"                         &&
          modify_local_config "EXTENSION" ".gz" ;;
      T)
          modify_local_config "COMPRESSBIN" ""       &&
          COMPRESSBIN=""                             &&
          modify_local_config "EXTENSION" ""         ;;
    esac
  done

}

#---------------------------------------------------------------------
## @param filename
## @return 0 if filename seems to be compressed
## @return 1 otherwise
## Returns true if the name of the file indicates that it should be
## a compressed file.  In other words, this function returns true if
## the extension is .gz, .tgz, .bz2, .zip, .rpm, .Z, .xz, .7z or .lzma.
##
#---------------------------------------------------------------------
filename_indicates_compression()  {
  grep -qE "^.*\.(gz|tgz|bz2|zip|Z|rpm|xz|7z|lzma)$" <<< "$1"
}

#---------------------------------------------------------------------
## Check that we have all the passed grimoires and use them to
## override the default selection (all)
#---------------------------------------------------------------------
override_grimoires() {
  local grimoires=$1
  local grimoire

  for grimoire in $grimoires; do
    if ! codex_find_grimoire $grimoire > /dev/null; then
      error_message "Grimoire $grimoire does not exist!"
      if query "Do you want to add it?" y; then
        scribe add $grimoire || exit 13
        echo
      else
        list_remove grimoires $grimoire
      fi
    fi
  done
  [[ -z $grimoires ]] && message "Using default grimoire selection!\n"

  export OVERRIDE_GRIMOIRES="$grimoires"
}

#---------------------------------------------------------------------
## Sets the most appropriate params for PAGER
## @Globals PAGER
#---------------------------------------------------------------------
set_pager() {
  if [[ -z $PAGER ]]; then
    if real_spell_ok less; then
      # pager info
      # -R: display color codes properly
      # -F: quit on one-screenfull of data (otherwise scribe pauses on empty updates)
      # -X: dont do screen init and deinit, gaze install
      # of a small spell is effectively useless otherwise as the
      # screen is cleared afterwards.
      # -f: force it, since we may not be dealing with a regular file
      PAGER="less -R -F -X -f"
    else
      PAGER=cat
    fi
    return
  fi

  local pager_prog
  local pager_params=${PAGER#* }
  smgl_basename "${PAGER%% *}" pager_prog
  # setting PAGER to a single word would give bad parameters
  [[ $pager_prog == $PAGER ]] && unset pager_params

  # TODO: add any needed options for the rest of the pagers
  case $pager_prog in
    less) PAGER="less -R -F -X -f $pager_params" ;;
    most) PAGER="most $pager_params" ;;
    w3m)  PAGER="w3m $pager_params" ;;
    more) PAGER="more $pager_params";;
    *) ;;
  esac
}

#---------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
