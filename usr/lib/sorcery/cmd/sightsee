#!/bin/sh
. /etc/sorcery/local/config
. /etc/sorcery/roots
unset debug verbose paths

upstream_rel_get() {
  [ -z "$debug" ] || >&2 echo "D: Visiting $1"
  case "$HTTP_DL_HANDLER" in
    (curl) curl -s "$1" ;;
    (*) wget -q -O- "$1" ;;
  esac | gawk -vdebug="$debug" -vfname="$2" '
	BEGIN {
		# Parse named capture groups
		num_parens = split(fname, text, /[()]/, parens) - 1
		for (i = 0; i < num_parens; i++) {
			if (parens[i] == "(") {
				last_group++
				if (match(text[i+1], /^\?<[^>]+>/)) {
					group_name = substr(text[i+1], \
						3, RLENGTH - 3)
					grpname2num[group_name] = last_group
				}
			}
		}
		split("", text)
		split("", parens)
		gsub(/\(\?<[^>]+>/, "(", fname) # Fixup regex

		# Shortcut
		version_group = "version" in grpname2num \
			? grpname2num["version"] : last_group
	}
	{
		while (match(tolower($0), fname, V)) {
			if (debug) {
				printf "D: matched `%s` -> `%s`\n", \
					substr($0, RSTART, RLENGTH), \
					V[version_group] \
					>"/dev/stderr"
			}
			print V[version_group]
			$0 = substr($0, RSTART + RLENGTH)
		}
	}
  ' | sort -urV
}

# Process options
while
  case "$1" in
    (--test)
      shift
      upstream_rel_get "$@"
      exit
      ;;
    (--codex)
      CODEX_ROOT="$2"
      shift 2
      ;;
    (--debug)
      debug=1
      shift
      ;;
    (-v|--verbose)
      verbose=1
      shift
      ;;
    (-h|--help)
      cat <<"!"

sightsee [spell...]	Find upstream software releases. Takes paths or spell
			names.
!
      exit 0
      ;;
    (*) false ;;
  esac
do :
done

if [ $# = 0 ]; then
  paths="$CODEX_ROOT"
else
  for i in "$@"; do
    case "$i" in
      (*/*) ;;
      (*)
        if ! [ -d "$i" ]; then
          j=$(find "$CODEX_ROOT" -maxdepth 3 -name "$i" -type d -print -quit)
          [ -d "$j" ] && i="$j"
        fi
        ;;
    esac
    paths+=("$i")
  done
fi

find "${paths[@]}" -name DETAILS -exec awk -vdebug="$debug" '
	END { print_spell() }
	FNR==1 {
		if (spell != "") print_spell()
	}
	/^ *SPELL=/ {
		spell = $0
		sub(/^[^=]+=["'\'']?/, "", spell)
		sub(/["'\'']$/, "", spell)
		next
	}
	/^ *VERSION=/ {
		version = $0
		sub(/[\t ]*[;#].*/, "", version)
		sub(/.*=["'\'']?/, "", version)
		sub(/["'\'']$/, "", version)
		if (watch_url != "") nextfile
	}
	/^# *Watch:/ {
		sub(/^[^:]+: */, "")
		watch_url = $1
		sub(/^[^ ]+ */, "")
		watch_regex = $0
		if (version != "") nextfile
	}
	function select_regex(spell, url) {
		version_re = "(?<version>[rv]?" \
			"([0-9]+[-_.+~])*[0-9]+(([a-z]|rc|alpha|beta)[0-9]*)?" \
			")"
		arch_re = "(" \
			"src|" \
			"sources?|" \
			"alpha|" \
			"(uefi-)?arm(64|el|hf)?|" \
			"aarch64|" \
			"hppa|" \
			"(hurd-|uefi-)?i[3-6]86|" \
			"x32|" \
			"ia64|" \
			"loong64|" \
			"m68k|" \
			"mips(64|n32)?(r6)?(el)?|" \
			"(uefi-)?(x86_|amd)64|" \
			"powerpc(spe)?|" \
			"ppc64(el)?|" \
			"riscv64|" \
			"s390x?|" \
			"sh4|" \
			"sparc(64)?|" \
			"noarch|" \
			"all" \
			")"
		if (url ~ /^https:\/\/github\.com\/.*\/tags$/)
			return "/archive/refs/tags/(v|" spell "-)?" version_re "[.]tar"
		if (url ~ /gitlab/)
			return "/" spell "/-/archive/(v|" spell "-)?" version_re "/" spell "-"
		return spell "([-_](src|sources?))?[-_]" version_re \
			"([-_.]" arch_re ")?" \
			"[.](orig[.])?" \
			"(tar|zip|t[bgx]z|7z|sha?r|cpio|rpm|deb|[ot]tf)"
	}
	function print_spell() {
		if (watch_url == "") {
			printf "W: %s: %s\n", spell, \
				"Upstream releases page not specified" \
				>"/dev/stderr"
		} else {
			if (!watch_regex)
				watch_regex = select_regex(spell, watch_url)
			if (debug)
				printf "D: regex `%s`\n", watch_regex >"/dev/stderr"
			print spell, version, watch_url, watch_regex
		}
		version = watch_url = spell = ""
	}
  ' {} + |
while read spell cur_rel url regex; do
  if [ -n "$debug" ]; then
    >&2 echo "D: current_release for $spell: $cur_rel"
  fi
  latest_rel=$(upstream_rel_get "$url" "$regex" | sed q) || continue
  if [ -z "$latest_rel" ]; then
    >&2 echo "W: $spell has no published releases, review the URL"
  elif [ "x$latest_rel" != "x$cur_rel" ]; then
    if [ -n "$debug" ]; then
      >&2 echo "D: latest release for $spell: $latest_rel"
    fi
    echo "$spell $latest_rel"
  elif [ -n "$verbose" ] || [ -n "$debug" ]; then
    >&2 echo "I: $spell is up to date"
  fi
done
